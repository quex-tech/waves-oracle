{-# STDLIB_VERSION 7 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func add(pool: ByteVector, action: ByteVector, proof: ByteVector, after: Int, before: Int) = {
    let keyBase = toBase58String(pool) + ":" + toBase58String(keccak256_16Kb(action)) + ":" + toBase58String(i.transactionId) + ":"
    let payment = getElement(i.payments, 0)
    if isDefined(payment.assetId) then throw("currency") else {
      [
          BinaryEntry(keyBase + "action", action),
          BinaryEntry(keyBase + "proof", proof),
          IntegerEntry(keyBase + "after", after),
          IntegerEntry(keyBase + "before", before),
          BinaryEntry(keyBase + "owner", i.originCaller.bytes),
          IntegerEntry(keyBase + "reward", payment.amount)
      ]
    }
}

@Callable(i)
func recycle(key: String) = {
  let keyBase = key + ":"
  let owner = getBinaryValue(keyBase + "owner")
  if owner != i.originCaller.bytes then throw("not yours") else {
    let before = getIntegerValue(keyBase + "before")
    if 1000*before >= lastBlock.timestamp then throw("too early") else {
      let reward = getIntegerValue(keyBase + "reward")
      [
        ScriptTransfer(i.originCaller, reward, unit),
        DeleteEntry(keyBase + "action"),
        DeleteEntry(keyBase + "proof"),
        DeleteEntry(keyBase + "after"),
        DeleteEntry(keyBase + "before"),
        DeleteEntry(keyBase + "owner"),
        DeleteEntry(keyBase + "reward")
      ]
    }
  }
}

@Callable(i)
func fulfill(res: ByteVector, pool: ByteVector, txId: ByteVector) = {
  let actIdL = toInt(res)
  let relayerL = toInt(res, 8 + actIdL)
  let time = toInt(res, 8 + actIdL + 8 + relayerL)
  strict actionId_ = invoke(Address(base58'ResponsesgQSB1AcUHHFzRUjMpx7j35YsQv'), "publish", [res, pool], [])
  let actionId = match actionId_ {
    case b: ByteVector => b
    case _ => throw("actionId")
  }
  let keyBase = toBase58String(pool) + ":" + toBase58String(actionId) + ":" + toBase58String(txId) + ":"
  let after = getIntegerValue(keyBase + "after")
  let before = getIntegerValue(keyBase + "before")
  if time < after || time > before then throw("time") else {
    let reward = getIntegerValue(keyBase + "reward")
    [
      ScriptTransfer(i.originCaller, reward, unit),
      DeleteEntry(keyBase + "action"),
      DeleteEntry(keyBase + "proof"),
      DeleteEntry(keyBase + "after"),
      DeleteEntry(keyBase + "before"),
      DeleteEntry(keyBase + "owner"),
      DeleteEntry(keyBase + "reward")
    ]
  }
}