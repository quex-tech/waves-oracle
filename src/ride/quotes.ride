{-# STDLIB_VERSION 9 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func readUInt(buf: ByteVector, off: Int, len: Int) = {
  toInt(toBigInt(base16'00' + drop(buf, off), 0, len + 1))
}

func readTL(buf: ByteVector, off: Int) = {
  let l0 = readUInt(buf, off + 1, 1)
  if l0 < 128 then (l0, off + 2)
  else {
    let n = l0 - 128
    (readUInt(buf, off + 2, n), off + 2 + n)
  }
}

func skipTLV(buf: ByteVector, off: Int) = {
  let (l, o) = readTL(buf, off)
  (o + l)
}

let z32 = base58'11111111111111111111111111111111'

func readCert(buf: ByteVector) = {
  let (certL, tbsO) = readTL(buf, 0)
  let (tbsL, verO) = readTL(buf, tbsO)
  let snO = skipTLV(buf, verO)
  let tbsSigO = skipTLV(buf, snO)
  let issO = skipTLV(buf, tbsSigO)
  let valO = skipTLV(buf, issO)
  let subO = skipTLV(buf, valO)
  let pkiO = skipTLV(buf, subO)
  let (pkiL, pkAlgO) = readTL(buf, pkiO)
  let pkO = skipTLV(buf, pkAlgO)
  let (pkL, pkValO) = readTL(buf, pkO)
  let sigO = skipTLV(buf, verO + tbsL)
  let (sigL, sigValO) = readTL(buf, sigO)
  let (sigSeqL, rIntO) = readTL(buf, sigValO + 1)
  let (rIntValL, rIntValO) = readTL(buf, rIntO)
  let (sIntValL, sIntValO) = readTL(buf, rIntValO + rIntValL)

  let tbs = take(drop(buf, tbsO), (verO - tbsO) + tbsL)
  let x_ = drop(buf, pkValO + 2)
  let x = take(x_, 32)
  let y = take(drop(x_, 32), 32)
  let r = takeRight(z32 + take(drop(buf, rIntValO), rIntValL), 32)
  let s = takeRight(z32 + take(drop(buf, sIntValO), sIntValL), 32)

  (tbs, x, y, r, s)
}

func validateChain(chain: List[ByteVector]) = {
  let (leafTbs, leafX, leafY, leafR, leafS) = readCert(chain[0])
  let (interTbs, interX, interY, interR, interS) = readCert(chain[1])
  let (rootTbs, rootX, rootY, rootR, rootS) = readCert(chain[2])
  if !p256Verify(interX, interY, leafR, leafS, sha256_16Kb(leafTbs)) then throw("sig leaf") else {
    if !p256Verify(rootX, rootY, interR, interS, sha256_16Kb(interTbs)) then throw("sig inter") else {
      if !p256Verify(rootX, rootY, rootR, rootS, sha256_16Kb(rootTbs)) then throw("sig root") else {
        (leafX, leafY)
      }
    }
  }
}

@Callable(i)
func register(
  quote: ByteVector,
  quoteSig: ByteVector,
  attestationKey: ByteVector,
  qeReport: ByteVector,
  qeReportSig: ByteVector,
  qeAuthData: ByteVector,
  qeCertChain: List[ByteVector]
) = {
  let (qeX, qeY) = validateChain(qeCertChain)
  if !p256Verify(qeX, qeY, take(qeReportSig, 32), drop(qeReportSig, 32), sha256_16Kb(qeReport)) then
    throw("sig qe")
  else {
    if sha256_16Kb(attestationKey + qeAuthData) + z32 != takeRight(qeReport, 64) then
      throw("report-data")
    else {
      let quoteId = sha256_16Kb(quote)
      if !p256Verify(take(attestationKey, 32), drop(attestationKey, 32), take(quoteSig, 32), drop(quoteSig, 32), quoteId) then
        throw("sig quote")
      else {
        let keyBase = toBase58String(quoteId) 
        [
          BinaryEntry(keyBase + ":quote", quote),
          BinaryEntry(keyBase + ":qe-report", qeReport)
        ]
      }
    }
  }
}
